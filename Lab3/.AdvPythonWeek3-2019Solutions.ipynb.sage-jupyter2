{"backend_state":"running","kernel":"python3","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":79253504},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.6.7"}},"trust":true,"type":"settings"}
{"cell_type":"code","end":1550518228791,"exec_count":3,"id":"d57546","input":"#Given function for xml imports_list\nimport glob\nimport xml.etree.ElementTree as ET\n\n# Function parseXML\n# Input: xml_file\n# Output array of elements with coordinates lat, lon, ele, time. \ndef parseXML(xml_file):\n    tree = ET.ElementTree(file=xml_file)\n    root = tree.getroot()\n    \n    xml=[]\n    for child in root[1]:\n        if child.tag == \"{http://www.topografix.com/GPX/1/1}trkseg\":\n            for step_child in child:\n                evt={} # declare a new dictionary\n                evt['lat'] = step_child.get('lat')\n                evt['lon'] = step_child.get('lon')\n                evt['ele'] = step_child[0].text\n                evt['time'] = step_child[1].text\n                \n                xml.append(evt)\n    return xml\n\n# Path may need adjusting, depending on folder configuration\nxml_file = glob.glob('../data/activity_779202142.gpx')\nxml = parseXML(xml_file[0])\n\n# Print out the size of the array\nprint(\"I read \",len(xml),\" elements\")\n\n","kernel":"python3","output":{"0":{"name":"stdout","text":"I read  3260  elements\n"}},"pos":1,"scrolled":true,"start":1550518228579,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":34,"id":"80d987","input":"## Tests and stuff ##\n\n# print(dtp.parse(ts[3]).total_seconds())\n# print(DiffT(xml[8].total_seconds))\n# \n# dLats, dLons, dEles = Diff(lats), Diff(lons), Diff(eles)\n# \n# diff = GeneralDiff(ts)\n# diff = DiffT(ts[4],ts[5])\n# print(diff)\n# \n# print(RelTime)\n# ","kernel":"python3","pos":5,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":85,"id":"f1b3c8","input":"import numpy as np\nimport matplotlib.pyplot as plt\nimport dateutil.parser as dtp\n\n#-------------------------------------------------------------------\n#So that we only need to run this block:\n\n#Given function for xml imports_list\nimport glob\nimport xml.etree.ElementTree as ET\n\n# Function parseXML\n# Input: xml_file\n# Output array of elements with coordinates lat, lon, ele, time. \ndef parseXML(xml_file):\n    tree = ET.ElementTree(file=xml_file)\n    root = tree.getroot()\n    xml=[]\n    for child in root[1]:\n        if child.tag == \"{http://www.topografix.com/GPX/1/1}trkseg\":\n            for step_child in child:\n                evt={} # declare a new dictionary\n                evt['lat'] = step_child.get('lat')\n                evt['lon'] = step_child.get('lon')\n                evt['ele'] = step_child[0].text\n                evt['time'] = step_child[1].text\n                xml.append(evt)\n    return xml\n\n# Path may need adjusting, depending on folder configuration\nxml_file = glob.glob('../data/activity_779202142.gpx')\nxml = parseXML(xml_file[0])\n\n#---------------------------------------------------------------------\n\n###################################################################\n###################################################################\n######################## F U N C T I O N S ########################\n###################################################################\n###################################################################\n\ndef Pos(xml_input):\n    \"\"\"Turns a dictionary of latitudes, longitudes, elevations, and times into a set of lists, converting from strings to relevant data types. Because honestly who wants to work with dictionaries for this\"\"\"\n    Lats = []\n    Lons = []\n    Eles = []\n    Times = []\n    for i in range (0, len(xml_input)):\n        Lats.append(float(xml_input[i]['lat']))\n        Lons.append(float(xml_input[i]['lon']))\n        Eles.append(float(xml_input[i]['ele']))\n        Times.append(dtp.parse(xml_input[i]['time']))\n    return(Lats, Lons, Eles, Times)\n\ndef DiffList(input_list):\n    \"\"\"Gives the difference between adjacent elements in a list\"\"\"\n    difflist = []\n    for i in range (0, len(input_list) - 1):\n        difflist.append(input_list[i + 1] - input_list[i])\n    return(difflist)\n\ndef CartPos(Lat, Lon, LatOrig, LonOrig):\n    \"\"\"Finds the Cartesian coordinates of a point given it's latitude and longitude, realtive to an origin point. Only accurate over short distances\"\"\"\n    rE = 6371 #Earth radius in km (I guess you can change this for marathons on other planets)\n    D2R = ((2 * np.pi) / (360))\n    YPos = ((float(Lat) - float(LatOrig)) * D2R) * rE\n    XPos = (((float(Lon) - float(LonOrig)) * D2R) * rE) #Apparently I need some correction factor here, but I don't know what it is or how to implement it\n    return(XPos, YPos)\n\ndef CartList(latlist, lonlist):\n    \"\"\"Gives lists of X & Y coordinates from lists of latitude & longitude coordinates. (Just an iterated version of CartPos)\"\"\"\n    Xs = []\n    Ys = []\n    for i in range (0, len(latlist)):\n        X, Y = CartPos(latlist[i], lonlist[i], latlist[0], lonlist[0])\n        Xs.append(X)\n        Ys.append(Y)\n    return(Xs, Ys)\n\ndef GeneralListPlot(XList, YList, xlabel, ylabel):\n    \"\"\"A general function to plot 2 lists of floats, and label their axes\"\"\"\n    plt.plot(XList, YList)\n    plt.xlabel(xlabel)\n    plt.ylabel(ylabel)\n    plt.show()\n    return()\n\ndef CartPlot(latlist, lonlist):\n    \"\"\"Plots the route travelled, in Cartesian coordinates\"\"\"\n    Xs, Ys = CartList(latlist, lonlist)\n    GeneralListPlot(Xs,Ys,'X Position (km)','Y Position (km)')\n    return()\n\ndef DiffT(time_1, time_2):\n    \"\"\"Finds the difference between 2 times in seconds\"\"\"\n    t1 = time_1\n    t2 = time_2\n    return((t2 - t1).total_seconds() )\n\ndef TimeDiffList(time_list):\n    \"\"\"Finds the differences between neighbouring time elements of a list, in seconds, and outputs them as a list\"\"\"\n    tDiffList = []\n    for i in range (0, len(time_list) - 1):\n        tDiffList.append(DiffT(time_list[i],time_list[i + 1]))\n    return(tDiffList)\n\ndef absDistTrav(latlist, lonlist):\n    \"\"\"Gives the absolute distance travelled, given a list of latitude and longitude positions\"\"\"\n    Xlist, Ylist = CartList(latlist, lonlist)\n    absDList = []\n    for i in range(0, len(latlist)): #lat & lon lists should be the same length.\n        absDList.append( np.sqrt( ((Xlist[i])**2) + ((Ylist[i])**2) ) ) # Is this outputting negatives at some point? HOW?!?!\n    TravDist = DiffList(absDList)\n    return(TravDist)\n\ndef CumulativeList(List): ### This is kinda pointless, but ya know, I've done it now\n    \"\"\"Cumulatively sums a list of values, outputting a list\"\"\"\n    CumuList = np.cumsum(List)\n    return(CumuList)\n\ndef RelTime(time_list):\n    \"\"\"Gives the time relative to the start time\"\"\"\n    Reltime = []\n    for i in range(0, len(time_list)):\n        Reltime.append( (time_list[i] - time_list[0]).total_seconds() )\n    return(Reltime)\n\ndef Velocity(latlist, lonlist, time_list): # WIP\n    dDist = DiffList( absDistTrav(latlist, lonlist) )\n#     Dist = absDistTrav(latlist, lonlist)\n    Time = RelTime(time_list)\n    Vel = []\n    for i in range (0, len(dDist)): #Hopefully both Dist & Time are same length\n        Vel.append( dDist[i] / Time[i] )\n    return(Vel)\n\n###########################################################################################################\n# DEAD BOYS - Functions that aren't useful/don't work/WIP                                                 #\n#                                                                                                         #\n# def DistTrav(dLat_list, dLon_list):                                                                     #\n#     \"\"\"Finds the distances traveled, in meters, along a list of changes in latitude and longitude\"\"\"    #\n#     dLatRad, dLonRad = np.deg2rad([dLat_list, dLon_list])                                               #\n#     dLatRad = dLat_list * ((2 * np.pi) / 360)                                                           #\n#     dLonRad = dLon_list * ((2 * np.pi) / 360)                                                           #\n#     dPhilist = []                                                                                       #\n#     Distlist = []                                                                                       #\n#     for i in range (0, len(dLatRad)): #Lat or Lon length should be the same, so can use either          #\n#         dPhilist.apppend( sqrt( dLatRad[i] ** 2 + dLonRad[i] ** 2) )                                    #\n#         Distlist.append( dPhilist[i] * 6371000) #Earth radius (m)                                       #\n#     return(Distlist)                                                                                    #\n#                                                                                                         #\n# It didn't like this very much, so I'm staying with the loop method                                      #\n# def GeneralDiff(input_list):                                                                            #\n#     \"\"\"Gives the differences of neighbouring elements in input_list, and outputs them as a list\"\"\"      #\n#     dList = input_list[1:] - input_list[:-1]                                                            #\n#     return(dList)                                                                                       #\n#                                                                                                         #\n# This is the same as the Diff function                                                                   #\n# def TimeDiffList(time_list):                                                                            #\n#     \"\"\"Finds the differences between neighbouring time elements of a list, and outputs them as a list\"\"\"#\n#     tDiffList = []                                                                                      #\n#     for i in range (0, len(time_list) - 1):                                                             #\n#         tDiffList.append(DiffT(time_list[i+1],timelist[i]))                                             #\n#     return(tDiffList)                                                                                   #\n#                                                                                                         #\n# Another attempt at time that didn't work                                                                #\n# def DiffT(xml_input):                                                                                   #\n#     dts = []                                                                                            #\n#     for i in range (0, len(xml) - 1):                                                                   #\n#         dts.append(dtp.parse(xml[i + 1]['time']) - dtp.parse(xml[i]['time']))                           #\n#     return(dts)                                                                                         #\n#                                                                                                         #\n# An attempt at time that didn't work                                                                     #\n# def DiffT(input_times_list):                                                                            #\n#     dffTlist = []                                                                                       #\n#     for i in range (0, len(input_times_list) - 1):                                                      #\n#         dffTlist.append(relativedelta(input_times_list[i], input_times_list[i + 1]))                    #\n#     return(dffTlist)                                                                                    #\n###########################################################################################################\n\n\n\n###################################################################\n###################################################################\n#################### T H E   P R O G R A M M E ####################\n###################################################################\n###################################################################\n\nlats, lons, eles, ts = Pos(xml) # Could probably have this as part of some function, or have Pos(xml) be called in any functions that use these 4 lists, but I don't feel like it's necessary right now, and it could potentially make the program slower overall.\n\nCartPlot(lats, lons)\n\nTravDist = absDistTrav(lats, lons)\nCumuDist = CumulativeList(TravDist)\nNewCumuDist = np.insert(CumuDist,0 ,0) # Cumulative list with a 0 on the front (as x = when t = 0)\nRelativeTSeconds = RelTime(ts)\nRelativeTMinutes = [x / 60 for x in RelativeTSeconds]\n\nGeneralListPlot(RelativeTMinutes , NewCumuDist, 'Time (minutes)', 'Distance (km)') # How is it getting a reducing distance?\n\n# GeneralListPlot(CumuDist, TimeDiffList(ts), 'Distance' ,'dt')  # This doesn't produce a pretty graph, need to change the function to be able to shift the graphs.\n\nNewVelList = np.insert(Velocity (lats, lons, ts),0 ,0)\nNewVelList = NewVelList * 1000\nGeneralListPlot(RelativeTMinutes, NewVelList, 'Time (minutes)', 'Velocity(m/s)')\n\n\n\nTotalTime = (ts[len(ts) - 1] - ts[0]).total_seconds()\nprint( \"Time taken for marathon: \", TotalTime, \"seconds\")\n\n# WHY IS NOTHING WORKING PROPERLY?!?!!? Given more time I'd start again. Can I suggest moving the deadline further? Given that some of us have other programming labs most of Tuesday.","kernel":"python3","output":{"0":{"data":{"image/png":"d8705607548117bffcb8a14faf26ed8abc2385d4"},"metadata":{"image/png":{"height":263,"width":384}}},"1":{"data":{"image/png":"b95504d1ede3b6aa800d5968ea9854e62f9dacd4"},"metadata":{"image/png":{"height":263,"width":384}}},"2":{"name":"stderr","text":"/usr/local/lib/python3.6/dist-packages/ipykernel/__main__.py:134: RuntimeWarning: divide by zero encountered in double_scalars\n"},"3":{"ename":"ValueError","evalue":"x and y must have same first dimension, but have shapes (3260,) and (3259,)","traceback":["\u001b[0;31m---------------------------------------------------------------------------\u001b[0m","\u001b[0;31mValueError\u001b[0m                                Traceback (most recent call last)","\u001b[0;32m<ipython-input-85-9f9a0a4a9dd9>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m()\u001b[0m\n\u001b[1;32m    203\u001b[0m \u001b[0mNewVelList\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0minsert\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mVelocity\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0mlats\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mlons\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mts\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m0\u001b[0m \u001b[0;34m,\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    204\u001b[0m \u001b[0mNewVelList\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mNewVelList\u001b[0m \u001b[0;34m*\u001b[0m \u001b[0;36m1000\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 205\u001b[0;31m \u001b[0mGeneralListPlot\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mRelativeTMinutes\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mNewVelList\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m'Time (minutes)'\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m'Velocity(m/s)'\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    206\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    207\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m<ipython-input-85-9f9a0a4a9dd9>\u001b[0m in \u001b[0;36mGeneralListPlot\u001b[0;34m(XList, YList, xlabel, ylabel)\u001b[0m\n\u001b[1;32m     80\u001b[0m \u001b[0;32mdef\u001b[0m \u001b[0mGeneralListPlot\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mXList\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mYList\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mxlabel\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mylabel\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     81\u001b[0m     \u001b[0;34m\"\"\"A general function to plot 2 lists of floats, and label their axes\"\"\"\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 82\u001b[0;31m     \u001b[0mplt\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mplot\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mXList\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mYList\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     83\u001b[0m     \u001b[0mplt\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mxlabel\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mxlabel\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     84\u001b[0m     \u001b[0mplt\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mylabel\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mylabel\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/usr/lib/python3/dist-packages/matplotlib/pyplot.py\u001b[0m in \u001b[0;36mplot\u001b[0;34m(*args, **kwargs)\u001b[0m\n\u001b[1;32m   3259\u001b[0m                       mplDeprecation)\n\u001b[1;32m   3260\u001b[0m     \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 3261\u001b[0;31m         \u001b[0mret\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0max\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mplot\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   3262\u001b[0m     \u001b[0;32mfinally\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   3263\u001b[0m         \u001b[0max\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_hold\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mwashold\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/usr/lib/python3/dist-packages/matplotlib/__init__.py\u001b[0m in \u001b[0;36minner\u001b[0;34m(ax, *args, **kwargs)\u001b[0m\n\u001b[1;32m   1716\u001b[0m                     warnings.warn(msg % (label_namer, func.__name__),\n\u001b[1;32m   1717\u001b[0m                                   RuntimeWarning, stacklevel=2)\n\u001b[0;32m-> 1718\u001b[0;31m             \u001b[0;32mreturn\u001b[0m \u001b[0mfunc\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0max\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1719\u001b[0m         \u001b[0mpre_doc\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0minner\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m__doc__\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1720\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0mpre_doc\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/usr/lib/python3/dist-packages/matplotlib/axes/_axes.py\u001b[0m in \u001b[0;36mplot\u001b[0;34m(self, *args, **kwargs)\u001b[0m\n\u001b[1;32m   1370\u001b[0m         \u001b[0mkwargs\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mcbook\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mnormalize_kwargs\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0m_alias_map\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1371\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1372\u001b[0;31m         \u001b[0;32mfor\u001b[0m \u001b[0mline\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_get_lines\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1373\u001b[0m             \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0madd_line\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mline\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1374\u001b[0m             \u001b[0mlines\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mappend\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mline\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/usr/lib/python3/dist-packages/matplotlib/axes/_base.py\u001b[0m in \u001b[0;36m_grab_next_args\u001b[0;34m(self, *args, **kwargs)\u001b[0m\n\u001b[1;32m    402\u001b[0m                 \u001b[0mthis\u001b[0m \u001b[0;34m+=\u001b[0m \u001b[0margs\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    403\u001b[0m                 \u001b[0margs\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0margs\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 404\u001b[0;31m             \u001b[0;32mfor\u001b[0m \u001b[0mseg\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_plot_args\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mthis\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    405\u001b[0m                 \u001b[0;32myield\u001b[0m \u001b[0mseg\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    406\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/usr/lib/python3/dist-packages/matplotlib/axes/_base.py\u001b[0m in \u001b[0;36m_plot_args\u001b[0;34m(self, tup, kwargs)\u001b[0m\n\u001b[1;32m    382\u001b[0m             \u001b[0mx\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0my\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mindex_of\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mtup\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m-\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    383\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 384\u001b[0;31m         \u001b[0mx\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0my\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_xy_from_xy\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mx\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0my\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    385\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    386\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcommand\u001b[0m \u001b[0;34m==\u001b[0m \u001b[0;34m'plot'\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/usr/lib/python3/dist-packages/matplotlib/axes/_base.py\u001b[0m in \u001b[0;36m_xy_from_xy\u001b[0;34m(self, x, y)\u001b[0m\n\u001b[1;32m    241\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0mx\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mshape\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m!=\u001b[0m \u001b[0my\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mshape\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    242\u001b[0m             raise ValueError(\"x and y must have same first dimension, but \"\n\u001b[0;32m--> 243\u001b[0;31m                              \"have shapes {} and {}\".format(x.shape, y.shape))\n\u001b[0m\u001b[1;32m    244\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0mx\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mndim\u001b[0m \u001b[0;34m>\u001b[0m \u001b[0;36m2\u001b[0m \u001b[0;32mor\u001b[0m \u001b[0my\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mndim\u001b[0m \u001b[0;34m>\u001b[0m \u001b[0;36m2\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    245\u001b[0m             raise ValueError(\"x and y can be no greater than 2-D, but have \"\n","\u001b[0;31mValueError\u001b[0m: x and y must have same first dimension, but have shapes (3260,) and (3259,)"]},"4":{"data":{"image/png":"c2c7f98904acb55efab09c52f0b8e5c9ac5e0381"},"metadata":{"image/png":{"height":252,"width":380}}}},"pos":2,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"8c613c","input":"## Exercise 4. Read and analyse an XML file from a GPS\nThe file *activity_779202142.gpx* in the \"data\" directory is downloaded from a GPS watch used to record a run (a marathon in this case). The file is in XML format. XML stands for \"eXtendible Markup Language\" and is a standard format used to pass information from different programs and on the internet. You can read more about XML for instance on the Wikipedia: https://en.wikipedia.org/wiki/XML\n\nPython has methods to navigate through an XML file and capture the information contained in it. The skeleton program below contains all the basics needed to open the file and access the information about the \"track\" corresponding to the run. \n\nYou should use *longitude* and *latitute* to convert the information into a 2D positions in metres, with (0,0) being the starting point. The *time* information, given in UTC, can be converted into seconds, with t=0s being the time of the first point. The elevation is given in metres. \n\nYou should look at the xml file (open it with an editor) to see how it is structured and understand how the piece of code provided below reads it and unpacks the information into an array of dictionaries. \n\nThe dictionaries can then put into numpy arrays to be used for your data analysis. This is not the most efficient way of doing this, as one could put the information straight into arrays. Doing this way, however, it is much easier to extract informatio of a specific entry (as shown below). \n\nThis operation of reading a file in a specific format, clean up the records, and eventually prepare everything in a format that can be easily analysed is often referred to as \"data wrangling\".\n\nOnce you have x, y, h and t (position, elevation, time) plot:\n- The route taken by the runner in the (x,y) plane in km\n- The distance run as a function of time (in minutes), with t=0 being the start of the run\n- The speed of the runner (in m/s) as a function of time (in min)\n- The speed of the runner (in m/s) as a function of the distance ran (in km)\n- The elevation (in m) as a function of the distance run (in km)\n- What was the time taken to run the \"white peak\" marathon?\n\n** Total [10 marks] ** ","pos":0,"state":"done","type":"cell"}
{"id":"96695e","input":"","pos":1.75,"state":"done","type":"cell"}
{"id":"e38425","input":"\"\"\" Examples given\n# Example of a printout of a specific record\nprint(\"coordinates of point 55\")\nprint(xml[55])\n\n# Example on how to get the Delta t between two points:\nimport dateutil.parser as dtp\nfrom dateutil.relativedelta import *\n\nt0=(dtp.parse(xml[0]['time']) )\nt55=(dtp.parse(xml[55]['time']) )\nprint(t0)\nprint(t55)\nprint(\"Delta time is:\",(t55-t0).total_seconds() )\n\n\n# Example of how to calculate a vector with the difference between adjacent elemets\n# deltaA=A[1:]-A[:-1] # Note the length of the vector will be n-1\n\n#Example of how to add elements of a vector and keep a cumulative sum\n# Asum=A.cumsum()\n\"\"\"","pos":1.5,"state":"done","type":"cell"}
{"id":0,"time":1552505794948,"type":"user"}
{"last_load":1550507504582,"type":"file"}