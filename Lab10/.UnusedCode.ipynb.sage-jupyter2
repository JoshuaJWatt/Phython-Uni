{"backend_state":"running","kernel":"python3","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":79695872},"trust":true,"type":"settings"}
{"cell_type":"code","exec_count":0,"id":"7c8530","input":"#### This Doesn't Work ####\n\n# effpullx-& effpully are the 2 best vars\n# We need to prepare the data sets, so they are in the form required by this NN\n# Test Data\nepxsigdat = np.array(sigframedat['effpullx'])\nepxbacdat = np.array(bacframedat['effpullx'])\n\nepysigdat = np.array(sigframedat['effpully'])\nepybacdat = np.array(bacframedat['effpully'])\n\n# Training Data\nepxsigtr = np.array(sigframetr['effpullx'])\nepxbactr = np.array(bacframetr['effpullx'])\n\nepysigtr = np.array(sigframetr['effpully'])\nepybactr = np.array(bacframetr['effpully'])\n\n# Attempt to automate classifications\n# def classify_data(data, classification = [0,1]):\n#     if classification == 1:\n#         classeddata = data.append(np.ones(len(data)))\n#     elif classification == 0:\n#         classeddata = data.append(np.zeros(len(data)))\n#     return(classeddata)\n\n\n# Defining that a 0 classification is background, 1 is the signal. And creating classification lists for both test and training data\n#         TODO: Automate /generalise this (ie, make a function)\nbacclassdat = []\nsigclassdat = []\nbacclasstr = []\nsigclasstr = []\n\nfor i in range(len(epxsigdat)):\n    sigclassdat.append(1)\n    bacclassdat.append(0)\n\nfor i in range(len(epxsigtr)):\n    sigclasstr.append(1)\n    bacclasstr.append(0)\n\n# Zipping this data:\n# The \"...data\" lists are our 'X' inputs, and the \"...class\" lists are our y inputs\n# Test data\n# We need to remember which way around these are, as our classifications need to be the same way around (so that everything lines up nicely)\nepxtestdata = zip(epxsigdat, epxbacdat)\ntestclass = zip(sigclassdat, bacclassdat)\n\nepxtraindata = zip(epxsigtr, epxbactr)\ntrainclass = zip(sigclasstr, bacclasstr)\n\n# I'm fairly sure we can reuse the classifications for the epy data\nepytestdata = zip(epysigdat, epybacdat)\nepytraindata = zip(epysigtr, epybactr)\n\n\n# Building a model\nX, y = epxtraindata, trainclass\n\n# Put this directly after wherever we set X\n# num_examples = len(X)\n\nmodel = build_model(3, print_loss=True,num_passes=500)\nplot_decision_boundary(lambda x: predict(model, x))\nplt.title(\"Decision Boundary for hidden layer size 3\")\nprint(\"Accuracy\",accuracy(lambda x: predict(model,x)) )","pos":0,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":0,"id":"8d25a5","input":"epxtest = testdata['effpullx']\nepytest = testdata['effpully']\nprint(epxtest)\nplt.scatter(epxtest, epytest)","pos":1,"state":"done","type":"cell"}
{"id":0,"time":1557153651584,"type":"user"}
{"last_load":1557071348125,"type":"file"}