{"backend_state":"running","kernel":"anaconda5","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":76738560},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.6.6"}},"trust":true,"type":"settings"}
{"cell_type":"code","end":1551112498897,"exec_count":8,"id":"42d8fb","input":"###### From lecture notes:\nimport math\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n#Define our own complex number class\nclass myComplex:\n\n    # __init__ is required for a class and specifies what happens when a new object is created\n    # in our case, the class holds two float numbers (the real and imaginary part) which are initialised\n    # by the arguments passed, or set to 0. if no arguments are passed\n    def __init__(self,x=0.,y=0.):\n        self.re=x\n        self.im=y\n        self.R = math.sqrt(self.re**2+self.im**2) # Making R a property for ease\n\n    # This are methods returning the modulus and phase of a complex number\n#     def R(self):\n#         return math.sqrt(self.re**2+self.im**2)\n    \n    def phi(self):\n        return math.atan2(self.im,self.re)\n\n    # Or we can set modulus and phase\n    def setRphi(self,R,phi):\n        self.re=R*math.cos(phi)\n        self.im=R*math.sin(phi)\n   \n    # Here we overload the \"+\" operator to add two numbers\n    def __add__(self,other):\n        return myComplex(self.re+other.re,self.im+other.im)\n    \n    # Here we over the operator needed to print out complex numbers\n    def __repr__(self):\n        return '%f + %f i' %(self.re,self.im)\n\n######\n\n    # Overload of \"-\", to subtract 2 numbers\n    def __sub___(self, other):\n        return myComplex(self.re - other.re, self.im - other.im)\n    \n    # Overload of \"*\"\n    def __mul__(self,other):\n        return myComplex(self.re * other.re - self.im * other.im, self.re * other.im + self.im * other.re)\n    \n#    # Overload of \"/\", using conjugate\n#     def __truediv__(self, other):\n#         return myComplex((__mul__(self.re, conj(other)))/(other.re**2 + other.im**2))\n    \n    #Overload of \"/\"\n    def __truediv2__(self, other):\n        return myComplex((self.re * other.re + self.im * other.im) / (other.re**2 + other.im**2)), ((self.im * other.re - self.re * other.im) / (other.re**2 + other.im**2))\n    \n    \n    # Finding complex conjugate\n    def conj(self):\n        return myComplex(self.re, - self.im)\n    \n    # Rotating by angle theta\n    def rotate(self, theta_input):\n        Th_fin = np.arccos(self.re / self.R) + theta_input #I suppose you could also use the 'phi' function here\n        return myComplex(self.R*math.cos(Th_fin), self.R*math.sin(Th_fin))\n\n\n# Impedence vs frequency\n\ndef ZCalc(R_, L, C, om): #Assuming all inputs are real. Using R_ to avoid any weird isssues with the R property\n    return myComplex(R_, ((1/(om*C))-(om*L)))\n\n# Moved  into the 'ZRPlot' function\n# \n# def ZRlist(R_, L, C, input_list):\n#     \"\"\"Returns a list of Z vals for a given set of omega vals(So that we can plot them)\"\"\"\n#     Z = []\n#     for i in range(0, len(input_list)):\n#         Z.append(ZCalc(R_, L, C, input_list[i]).R)\n#     return(Z)\n\ndef GeneralListPlot(XList, YList, xlabel, ylabel):\n    \"\"\"A general function to plot 2 lists of floats, and label their axes\"\"\"\n    plt.plot(XList, YList)\n    plt.xlabel(xlabel)\n    plt.ylabel(ylabel)\n    plt.show()\n    return()\n\n# Plot mod Z vs omega, for L = 1000H, C=1 mF, R=480 Ohm\n# \n# I wrote this without a function, but I think (given that I need to call it 5 times) I should use a function\n# omega = np.arange(0.5, 100, 0.5) #Starting at 0 gives a 'divide by 0' error\n# ZR = ZRlist(480, 1000, 0.001, omega)\n# GeneralListPlot(omega, ZR, 'Frequency', 'Z')\n\ndef ZRPlot(R_, L, C, omega_min, omega_max, omega_step): # could also have it intake different vars to form the omega list\n    omega_list = np.arange(omega_min, omega_max, omega_step)\n    Zlist = []\n    for i in range(0, len(omega_list)):\n        Zlist.append(ZCalc(R_, L, C, omega_list[i]).R)\n    GeneralListPlot(omega_list, Zlist, 'Frequency', 'Z')\n\nprint(\"Plot mod Z vs omega, for L = 1000H, C=1 mF, R=480 Ohm\")\nZRPlot(480, 1000, 0.001, 0.5, 100, 0.5)\n\n# Repeat with R=120 Ohm and 960 Ohm (and L=1000H and C=1 mF)\nprint(\"Repeat with R=120 Ohm\")\nZRPlot(120, 1000, 0.001, 0.5, 100, 0.5)\nprint(\"and 960 Ohm\")\nZRPlot(960, 1000, 0.001, 0.5, 100, 0.5)\n# Repeat with L=200 H and L=2000 H (and R=480 Ohm and C=1 mF)\nprint(\"Repeat with L=200 H\")\nZRPlot(480, 200, 0.001, 0.5, 100, 0.5)\nprint(\"and L=2000 H\")\nZRPlot(480, 2000, 0.001, 0.5, 100, 0.5)\n","kernel":"anaconda5","output":{"0":{"name":"stdout","text":"Plot mod Z vs omega, for L = 1000H, C=1 mF, R=480 Ohm\n"},"1":{"data":{"image/png":"4f740c1456a71a59bb910c8b3aca72b74e0e2bc0"},"metadata":{"image/png":{"height":263,"width":410},"needs_background":"light"}},"2":{"name":"stdout","text":"Repeat with R=120 Ohm\n"},"3":{"data":{"image/png":"cd9060ee8331684e4f8974b95423419fccb67fb5"},"metadata":{"image/png":{"height":263,"width":410},"needs_background":"light"}},"4":{"name":"stdout","text":"and 960 Ohm\n"},"5":{"data":{"image/png":"afeab2c516862cf07d82fe72a0f65f8b7e1316bd"},"metadata":{"image/png":{"height":263,"width":410},"needs_background":"light"}},"6":{"name":"stdout","text":"Repeat with L=200 H\n"},"7":{"data":{"image/png":"32650657521295fc504e9f5464338aadb52cc10f"},"metadata":{"image/png":{"height":263,"width":403},"needs_background":"light"}},"8":{"name":"stdout","text":"and L=2000 H\n"},"9":{"data":{"image/png":"5fcbb3167832488129124ee6d1796db5732edf67"},"metadata":{"image/png":{"height":263,"width":410},"needs_background":"light"}}},"pos":1,"start":1551112496511,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":0,"id":"56df2d","input":"","pos":3,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":71,"id":"1c43b1","input":"##### a = myComplex(0, 1)\n\nmyComplex.rotate(a, 90)\n\nZCalc(1, 5, 8, 45)","pos":2,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"5b8533","input":"# Lab 4. Work on complex numbers and classes\n**Note** This topic is relatively simple, so it is marked out of a total of 7 marks. \n\n### Extend myComplex\nThe work is based upon the \"myComplex\" class defined in the Topic 3 lecture. You should extend the myComplex class and add overloaded methods for the following. Read the documentation at https://docs.python.org/3/library/operator.html to find out how to overload these operators:\n   * subtraction \n   * multiplication\n   * division\n\nWrite methods to calculate:\n   * The complex conjugate\n   * Rotate the phase of a complex number by an angle given as argument\n\nPerform a few tests with a few example numbers to ensure things work as expected\n\n### Impedence vs frequency\nThe impedence of an RLC circuit is given by:\n$$ Z = R + i \\left(\\frac{1}{\\omega C} - \\omega L \\right) $$\n\n   * Write a functions that calculates Z, given the four parameters R, L, C, omega\n   * Fix L = 1000H, C=1 mF, R=480 Ohm. Plot the modulus of Z vs omega\n   * Repeat with R=120 Ohm and 960 Ohm (and L=1000H and C=1 mF)\n   * Repeat with L=200 H and L=2000 H (and R=480 Ohm and C=1 mF)\n   * Plot the phase of Z vs omega\n   * Repeat the 3 points above using the python cmath.complex type","pos":0,"state":"done","type":"cell"}
{"id":0,"time":1551261820757,"type":"user"}
{"last_load":1551111535615,"type":"file"}