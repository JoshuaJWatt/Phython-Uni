{"backend_state":"running","kernel":"anaconda5","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":77340672},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.6.6"}},"trust":true,"type":"settings"}
{"cell_type":"code","exec_count":0,"id":"8c1b63","input":"","pos":3,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":7,"id":"69e7b1","input":"###### Imports\nimport math\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport cmath\n\n###### From lecture notes:\n#Define our own complex number class\nclass myComplex:\n\n    # __init__ is required for a class and specifies what happens when a new object is created\n    # in our case, the class holds two float numbers (the real and imaginary part) which are initialised\n    # by the arguments passed, or set to 0. if no arguments are passed\n    def __init__(self,x=0.,y=0.):\n        self.re=x\n        self.im=y\n        # Making R  & phi attributes, for ease\n        self.R = math.sqrt(self.re**2+self.im**2)\n        self.phi = math.atan2(self.im,self.re)\n\n    # This are methods returning the modulus and phase of a complex number\n#     def R(self):\n#         return math.sqrt(self.re**2+self.im**2)\n    \n#     def phi(self):\n#         return math.atan2(self.im,self.re)\n\n    # Or we can set modulus and phase\n    def setRphi(self,R,phi):\n        self.re=R*math.cos(phi)\n        self.im=R*math.sin(phi)\n   \n    # Here we overload the \"+\" operator to add two numbers\n    def __add__(self,other):\n        return myComplex(self.re+other.re,self.im+other.im)\n    \n    # Here we over the operator needed to print out complex numbers\n    def __repr__(self):\n        return '%f + %f i' %(self.re,self.im)\n\n######\n\n    # Overload of \"-\", to subtract 2 numbers\n    def __sub___(self, other):\n        return myComplex(self.re - other.re, self.im - other.im)\n    \n    # Overload of \"*\"\n    def __mul__(self,other):\n        return myComplex(self.re * other.re - self.im * other.im, self.re * other.im + self.im * other.re)\n    \n#    # Overload of \"/\", using conjugate\n#     def __truediv__(self, other):\n#         return myComplex((__mul__(self.re, conj(other)))/(other.re**2 + other.im**2))\n    \n    #Overload of \"/\"\n    def __truediv__(self, other):\n        return myComplex((self.re * other.re + self.im * other.im) / (other.re**2 + other.im**2)), ((self.im * other.re - self.re * other.im) / (other.re**2 + other.im**2))\n    \n    \n    # Finding complex conjugate\n    def conj(self):\n        return myComplex(self.re, - self.im)\n    \n    # Rotating by angle theta\n    def rotate(self, theta_input):\n        Th_fin = np.arccos(self.re / self.R) + theta_input #I suppose you could also use the 'phi' function here\n        return myComplex(self.R*math.cos(Th_fin), self.R*math.sin(Th_fin))\n\n\n# Impedence vs frequency\n\ndef ZCalc(R_, L, C, om): #Assuming all inputs are real. Using R_ to avoid any weird isssues with the R property\n    return myComplex(R_, ((1/(om*C))-(om*L)))\n\n# Moved  into the 'ZRPlot' function\n# \n# def ZRlist(R_, L, C, input_list):\n#     \"\"\"Returns a list of Z vals for a given set of omega vals(So that we can plot them)\"\"\"\n#     Z = []\n#     for i in range(0, len(input_list)):\n#         Z.append(ZCalc(R_, L, C, input_list[i]).R)\n#     return(Z)\n\ndef GeneralListPlot(XList, YList, xlabel, ylabel):\n    \"\"\"A general function to plot 2 lists of floats, and label their axes\"\"\"\n    plt.plot(XList, YList)\n    plt.xlabel(xlabel)\n    plt.ylabel(ylabel)\n    plt.show()\n    return()\n\n# Plot mod Z vs omega, for L = 1000H, C=1 mF, R=480 Ohm\n# \n# I wrote this without a function, but I think (given that I need to call it 5 times) I should use a function\n# omega = np.arange(0.5, 100, 0.5) #Starting at 0 gives a 'divide by 0' error\n# ZR = ZRlist(480, 1000, 0.001, omega)\n# GeneralListPlot(omega, ZR, 'Frequency', 'Z')\n\ndef ZRPlot(R_, L, C, omega_min, omega_max, omega_step): # could also have it intake different vars to form the omega list\n    omega_list = np.arange(omega_min, omega_max, omega_step)\n    Zlist = [] # List of R values\n    for i in range(0, len(omega_list)):\n        Zlist.append(ZCalc(R_, L, C, omega_list[i]).R)\n    GeneralListPlot(omega_list, Zlist, 'Frequency', 'Z')\n\ndef ZphiPlot(R_, L, C, omega_min, omega_max, omega_step):\n    omega_list = np.arange(omega_min, omega_max, omega_step)\n    Zlist = [] # List of phi values\n    for i in range(0, len(omega_list)):\n        Zlist.append(ZCalc(R_, L, C, omega_list[i]).phi)\n    GeneralListPlot(omega_list, Zlist, 'Frequency', 'Z Phase')\n\n###Cmath functions\ndef ZCalcCmath(R_, L, C, om):\n    return(complex(R_, ((1/(om*C))-(om*L))))\n    \ndef ZListCmath(R_, L, C, omega_min, omega_max, omega_step):\n    omega_list = np.arange(omega_min, omega_max, omega_step)\n    Zrlist = []\n    Zphilist = [] # I know cmath has a separate phase function, but I may as well use this right now. Though this is only used once, so I may write a new function for plotting phase\n    for i in omega_list:\n        r, phi = cmath.polar(ZCalcCmath(R_, L, C, i))\n        Zrlist.append(r)\n        Zphilist.append(phi)\n    return(Zrlist, Zphilist, omega_list) # We can't just Plot them here, as we don't always want the phi plots, we can just put these through the general plot function though\n\n#First plot of mod Z\nprint(\"Plot mod Z vs omega, for L = 1000H, C=1 mF, R=480 Ohm\")\nZRPlot(480, 1000, 0.001, 0.5, 100, 0.1)\n\n# Repeat with R=120 Ohm and 960 Ohm (and L=1000H and C=1 mF)\nprint(\"Repeat with R=120 Ohm\")\nZRPlot(120, 1000, 0.001, 0.5, 100, 0.1)\nprint(\"and 960 Ohm\")\nZRPlot(960, 1000, 0.001, 0.5, 100, 0.1)\n# Repeat with L=200 H and L=2000 H (and R=480 Ohm and C=1 mF)\nprint(\"Repeat with L=200 H\")\nZRPlot(480, 200, 0.001, 0.5, 100, 0.1)\nprint(\"and L=2000 H\")\nZRPlot(480, 2000, 0.001, 0.5, 100, 0.1)\n\nprint(\"Plot the phase of Z vs omega\") #Presumably for L = 1000H, C=1 mF, R=480 Ohm\nZphiPlot(480, 1000, 0.001, -2*np.pi, 2*np.pi, 0.1)\n\n\n# I'm not sure which 3 points he's wanting, so I'll just attempt all of them\n\n# Write a functions that calculates Z, given the four parameters R, L, C, omega\n# Fix L = 1000H, C=1 mF, R=480 Ohm. Plot the modulus of Z vs omega\n# Repeat with R=120 Ohm and 960 Ohm (and L=1000H and C=1 mF)\n# Repeat with L=200 H and L=2000 H (and R=480 Ohm and C=1 mF)\n# Plot the phase of Z vs omega\n# Repeat the 3 points above using the python cmath.complex type\n\n\n###Presumably for all these plots I could keep reusing the first set of list variables, replacing them after each plot, but I forgot python ran chronologically whilst I was writing, and I'm not going back now. Note: stop using capital letters in python\nprint(\"Fix L = 1000H, C=1 mF, R=480 Ohm. Plot the modulus of Z vs omega, with cmath\")\nZrList1, Zphilist1, omega_list1 = ZListCmath(480, 1000, 0.001, 0.5, 100, 0.1)\nGeneralListPlot(omega_list1, ZrList1, 'Frequency', 'Z')\n\nprint(\"Repeat with R=120 Ohm, with cmath\")\nZrList2, Zphilist2, omega_list2 = ZListCmath(120, 1000, 0.001, 0.5, 100, 0.1)\nGeneralListPlot(omega_list2, ZrList2, 'Frequency', 'Z')\nprint(\"and 960 Ohm (and L=1000H and C=1 mF), with cmath\")\nZrList3, Zphilist3, omega_list3 = ZListCmath(960, 1000, 0.001, 0.5, 100, 0.1)\nGeneralListPlot(omega_list3, ZrList3, 'Frequency', 'Z')\n\nprint(\"Repeat with L=200 H, with cmath\")\nZrList4, Zphilist4, omega_list4 = ZListCmath(480, 200, 0.001, 0.5, 100, 0.1)\nGeneralListPlot(omega_list4, ZrList4, 'Frequency', 'Z')\nprint(\"and L=2000 H (and R=480 Ohm and C=1 mF), with cmath\")\nZrList5, Zphilist5, omega_list5 = ZListCmath(480, 2000, 0.001, 0.5, 100, 0.1)\nGeneralListPlot(omega_list5, ZrList5, 'Frequency', 'Z')\n\nprint(\"Plot the phase of Z vs omega, with cmath\") #Presumably for L = 1000H, C=1 mF, R=480 Ohm, again\nZrList6, Zphilist6, omega_list6 = ZListCmath(480, 1000, 0.001, -2*np.pi, 2*np.pi, 0.1)\nGeneralListPlot(omega_list6, Zphilist6, 'Phase', 'Z')","output":{"0":{"name":"stdout","output_type":"stream","text":"Plot mod Z vs omega, for L = 1000H, C=1 mF, R=480 Ohm\n"},"1":{"more_output":true}},"pos":1,"scrolled":true,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":71,"id":"8bc870","input":"a = myComplex(0, 1)\n\nmyComplex.rotate(a, 90)\n\nZCalc(1, 5, 8, 45)","pos":2,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"1f6f8a","input":"# Lab 4. Work on complex numbers and classes\n**Note** This topic is relatively simple, so it is marked out of a total of 7 marks. \n\n### Extend myComplex\nThe work is based upon the \"myComplex\" class defined in the Topic 3 lecture. You should extend the myComplex class and add overloaded methods for the following. Read the documentation at https://docs.python.org/3/library/operator.html to find out how to overload these operators:\n   * subtraction \n   * multiplication\n   * division\n\nWrite methods to calculate:\n   * The complex conjugate\n   * Rotate the phase of a complex number by an angle given as argument\n\nPerform a few tests with a few example numbers to ensure things work as expected\n\n### Impedence vs frequency\nThe impedence of an RLC circuit is given by:\n$$ Z = R + i \\left(\\frac{1}{\\omega C} - \\omega L \\right) $$\n\n   * Write a functions that calculates Z, given the four parameters R, L, C, omega\n   * Fix L = 1000H, C=1 mF, R=480 Ohm. Plot the modulus of Z vs omega\n   * Repeat with R=120 Ohm and 960 Ohm (and L=1000H and C=1 mF)\n   * Repeat with L=200 H and L=2000 H (and R=480 Ohm and C=1 mF)\n   * Plot the phase of Z vs omega\n   * Repeat the 3 points above using the python cmath.complex type","pos":0,"state":"done","type":"cell"}
{"id":0,"time":1553033443356,"type":"user"}
{"last_load":1552312173224,"type":"file"}