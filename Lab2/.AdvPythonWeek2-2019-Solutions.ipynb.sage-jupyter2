{"backend_state":"running","kernel":"anaconda5","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":76816384},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.6.6"}},"trust":true,"type":"settings"}
{"cell_type":"code","exec_count":0,"id":"752bdd","input":"","pos":7,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":16,"id":"526c5c","input":"import numpy as np\nimport matplotlib.pyplot as plt\n\n\"\"\"\nWe're going to make a matrix of 0s & 1s, then change the first line to 100s, then multiply by the results of each run of the method (or maybe just replace them, we'll see)\n\nThis will all be cleaned up and turned into functions in the next block, this is just my workings\n\"\"\"\n# Define constants\nC=900  # J/(kg K)\nRh=2700 # kg/m3\nk=220  # W/(m K)\n\n# Define parameters of the problem\nL=0.3 # m\nT0=100.  # C\n\ndX = 0.01\ndt = 0.5\ntMax = 100\n\nXwidth = round(L/dX)\ntwidth = round(tMax/dt)\nEta = (k * dt) / (C * Rh * (dX**2))\n\n#Just sanity checks\n# print(Xwidth)\n# print(twidth)\n# print(Eta)\n\n\"\"\"\n# Number of points along x and t. Note! We need to do 31 and 201 points to get the correct Delta X and Delta T. \ndef LeapFrog(NPx,NPt,tmax): #I have no idea what this is or why it is here\n\"\"\"\n\n#Make some lists:\nTinit = np.ones((twidth + 1, Xwidth + 1))\nTinit[0] = Tinit[0] * T0 #First line should be 100s & 0s\n\nfor y in range (0, twidth + 1): #For all lines, first and last digit are 0\n    Tinit[y, 0] = 0\n    Tinit[y, Xwidth] = 0\n\nTMat = Tinit\n# print(Tinit)\n# print(TMat)\n\nfor j in range (0, twidth):\n    for i in range (1, Xwidth):\n        TMat[j + 1,i] = TMat[j,i] + Eta * (TMat[j,i + 1] + TMat[j,i - 1] - 2 * TMat[j,i])\n\nprint(TMat)\n","kernel":"anaconda5","output":{"0":{"name":"stdout","text":"[[  0. 100. 100. 100. 100. 100. 100. 100. 100. 100. 100. 100. 100. 100.\n  100. 100. 100. 100. 100. 100. 100. 100. 100. 100. 100. 100. 100. 100.\n  100. 100.   0.]]\n"}},"pos":2,"scrolled":false,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"025bf3","input":"### General reference\nThis project was inspired by Chapter 14 of the book \"Computational Physics\" by Laundau, Paez and Bordeianu published by Wiley. There should be a few copies available in the library. ","pos":6,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"1a7b21","input":"## Compute performance (PHY428)\n- Using the leap-frog numerical solution, show the time needed to evaluate the first 100 s of the solution as a function of $\\Delta x$ and $\\Delta t$. Present two graphs, one where $\\Delta x$ is fixed and one when $\\Delta t$ is fixed. Mark on the graph where the $\\eta=0.5$ condition is reached.\n","pos":4,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"79bb78","input":"## Code the numerical solution\nWrite code to calculate $T_{ij}$ in a recursive manner. \n- Plot T(x,t) for t=0, 20, 100s and compare with the plot in Exercise 1\n- Repeat the 3-D $T(x,t)$ wireframe plot of Exercise 1. ","pos":1,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"7a9aea","input":"#### Stability study\nIn this section we evaluate how the quality of our solution depends on the choice of $\\Delta x$ and $\\Delta t$. We will not be able to find a stable solution if the value of $\\eta>0.5$. This can be checked using the cases below. For each of the 4 cases below calculate the value of $eta$ and plot $T(x,t=100s)$\n- Fix $\\Delta x = 0.01$ m and change the value of $\\Delta t$ to 0.2 s and 1 s. Compare the results with those obtained in exercise 2. \n- Fix $\\Delta t = 0.5$ s and change the value of $\\Delta x$ to 0.02 m and 0.005 m. Compare the results with those obtained in exercise 2.\n\nA mathematical proof of the instability for $\\eta>0.5$ is provided in addendum. \n","pos":3,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"a204b0","input":"## Addendum. Calculation of the stability limit\nYou noticed that the difference between the analytical solution and the leap frog solution exhibits wild fluctuations when the leap frog solution does not converge. When that happens the solution is not stable. To assess the value of the parameter for which we obtain a stable solution, we assume that the difference has eigenmodes:\n$$T_{m,j}=\\xi(\\lambda)^j \\exp \\left( {i \\frac{2\\pi}{\\lambda} m \\Delta x } \\right)$$\nWhere we use $i$ as the imaginary constant and $T_{m,j}$ refers to the temperature at time $j \\Delta t$ for the point $m \\Delta x$. \n\nThis formula tells us that any eigenmode in the difference gets amplified or damped at every iteration by a factor $\\xi$, which depends on the wavelength $\\lambda$ of the mode. Replacing the equation above into the formula used for the leap-frog method we obtain:\n$$\\xi(\\lambda)^{j+1} \\exp \\left(i \\frac{2\\pi}{\\lambda} m \\Delta x \\right) = \\xi(\\lambda)^{j} \\exp \\left(i \\frac{2\\pi}{\\lambda} m \\Delta x  \\right)+ \\eta \\left[  \\exp \\left(i \\frac{2\\pi}{\\lambda} (m+1) \\Delta x  \\right)  + \\exp \\left(i \\frac{2\\pi}{\\lambda} (m-1) \\Delta x  \\right) -2 \\exp \\left(i \\frac{2\\pi}{\\lambda} m \\Delta x  \\right)   \\right]$$\n\nDividing both sides of the equation by $ \\xi(\\lambda)^{j} \\exp \\left(i \\frac{2\\pi}{\\lambda} m \\Delta x \\right)$ we obtain:\n$$\\xi(\\lambda) = 1 + 2 \\eta \\left[ \\cos \\left( \\frac{2\\pi}{\\lambda} m \\Delta x  \\right) -1 \\right] $$\n\nFor the quantity $|\\xi|<1$ for any value of $x$, we need to have $\\eta < 0.5$\n","pos":5,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"b354f7","input":"# The Heat equation - part 2\n\n## Numerical solutions\nA solution can be found numerically using time steps with the so-called \"leap frog\" method. To do this we replace the derivative in time with the approximation\n$$\\frac{\\partial T(x,t)}{\\partial t} = \\frac{T(x,t+\\Delta t)-T(x,t)}{\\Delta t} + ...$$\nTo approximate the second derivative over $x$ we write\n$$T(x+\\Delta x,t ) = T(x,t) + \\frac{\\partial T(x,t)}{\\partial x} \\Delta x + \\frac{1}{2} \\frac{\\partial^2 T(x,t)}{\\partial x^2} (\\Delta x)^2+...$$\n$$T(x-\\Delta x,t ) = T(x,t) - \\frac{\\partial T(x,t)}{\\partial x} \\Delta x + \\frac{1}{2} \\frac{\\partial^2 T(x,t)}{\\partial x^2} (\\Delta x)^2+...$$\nAdding the two terms and solving for the second derivative we obtain\n$$\\frac{\\partial^2 T(x,t)}{\\partial x^2} = \\frac{1}{\\Delta x^2} \\left[T(x+\\Delta x)+T(x-\\Delta x)-2T(x,t) \\right]$$\nSubstituting both approximations in the heat equations\n$$\\frac{T(x,t+\\Delta t)-T(x,t)}{\\Delta t} = \\frac{k}{c \\rho} \\frac{1}{\\Delta x^2} \\left[T(x+\\Delta x)+T(x-\\Delta x)-2T(x,t) \\right]$$\nBy which we get\n$$T(x,t+\\Delta t)=T(x,t) + \\eta \\left[ T(x+\\Delta x)+T(x-\\Delta x)-2T(x,t) \\right] \\ \\ \\ , \\ \\eta=\\frac{k \\Delta t}{c \\rho \\Delta x^2} $$\nThus we can evaluate the value of $T(x,t+\\Delta t)$ once the value of $T(x,t)$ is known. The numerical method will consist in starting with the given initial condition at $t=0$ and propagate that forward in time, hence the name of \"leap frog\".\n\nCreate a matrix of points $T_{i,j}$ with intervals $\\Delta t$ and $\\Delta x$ and solve the equation using the leapfrog method:\n$$T_{i,j+1}=T_{i,j} + \\eta \\left[T_{i+1,j}+T_{i-1,j}-2T_{i,j} \\right], \\ \\ \\ \\eta=\\frac{k\\Delta t}{C \\rho \\Delta x^2}$$\nWhere we have indicated $x=i \\Delta x$ and $t=j \\Delta t$. Start by using $\\Delta x=0.01$m and $\\Delta t=0.5$s ","pos":0,"state":"done","type":"cell"}
{"end":1550105444362,"exec_count":31,"id":"c637a3","input":"#Stability Study:\n\ndef EtaCalc(dX, dt):\n    return((k * dt) / (C * Rh * (dX**2)))\n\nplt.plot(LeapfrogLast(0.01, 0.2, 100, 100, 0.3)) #For t = 100, dx = 0.01, dt = 0.2 This is similar to the t=20 plot in Ex. 2\nplt.xlabel('X Position *10-2')\nplt.ylabel('T')\nplt.show()\nprint('Eta = ', EtaCalc(0.01, 0.2))\n\n#These next 3 all look similar to the t=0 plot\nplt.plot(LeapfrogLast(0.01, 1, 0, 100, 0.3)) #For t = 100, dx = 0.01, dt = 1\nplt.xlabel('X Position *10-2')\nplt.ylabel('T')\nplt.show()\nprint('Eta = ', EtaCalc(0.01, 1)) #Eta > 0.5, thus we cannot find a stable solution\n\n\nplt.plot(LeapfrogLast(0.02, 0.5, 0, 100, 0.3)) #For t = 100, dx = 0.02, dt = 0.5\nplt.xlabel('X Position *10-2')\nplt.ylabel('T')\nplt.show()\nprint('Eta = ', EtaCalc(0.2, 0.5))\n\nplt.plot(LeapfrogLast(0.005, 0.5, 0, 100, 0.3)) #For t = 100, dx = 0.005, dt = 0.5\nplt.xlabel('X Position *10-2')\nplt.ylabel('T')\nplt.show()\nprint('Eta = ', EtaCalc(0.005, 0.5)) #Eta > 0.5, thus we cannot find a stable solution\n","kernel":"anaconda5","output":{"0":{"data":{"image/png":"ba99a2d81cffe6e3aeafc55852ccbff7d78ecb91"},"metadata":{"image/png":{"height":263,"width":390},"needs_background":"light"}},"1":{"name":"stdout","text":"Eta =  0.18106995884773663\n"},"2":{"data":{"image/png":"6e72aacbdfe3e04e8820e37ee41c088403c4be85"},"metadata":{"image/png":{"height":263,"width":390},"needs_background":"light"}},"3":{"name":"stdout","text":"Eta =  0.9053497942386831\n"},"4":{"data":{"image/png":"3df9f409154c58eebb6441044fb689383ce86672"},"metadata":{"image/png":{"height":263,"width":390},"needs_background":"light"}},"5":{"name":"stdout","text":"Eta =  0.0011316872427983538\n"},"6":{"data":{"image/png":"6865cd91747e0a69979f28f15bc471ad11a38e79"},"metadata":{"image/png":{"height":263,"width":390},"needs_background":"light"}},"7":{"name":"stdout","text":"Eta =  1.8106995884773662\n"}},"pos":3.5,"start":1550105442324,"state":"done","type":"cell"}
{"exec_count":25,"id":"f4781f","input":"#Tests/Debug\n\n# X, T = ThrDPlot(0.01, 0.5, 100, 100, 0.3)\n# print(X, T)\n\n# TMat = LeapfrogFull(0.01, 0.5, 100, 100, 0.3)\n# TVAL = TMat[1, 2]\n# print(TMat)\n# print('-----------------------------------------------------------------------')\n# print(TVAL)\n\n# print(LeapfrogLast(0.01, 0.5, 100, 100, 0.3))\n\n# def EtaCalc(dX, dt)\n#     return((k * dt) / (C * Rh * (dX**2)))\n\n","kernel":"anaconda5","output":{"0":{"name":"stdout","text":"[[  0.         100.         100.         ... 100.         100.\n    0.        ]\n [  0.          54.73251029 100.         ... 100.          54.73251029\n    0.        ]\n [  0.          50.44793307  79.50854375 ...  79.50854375  50.44793307\n    0.        ]\n ...\n [  0.           4.96995957   9.88532399 ...   9.88532399   4.96995957\n    0.        ]\n [  0.           4.94524572   9.8361734  ...   9.8361734    4.94524572\n    0.        ]\n [  0.           4.92065731   9.78727205 ...   9.78727205   4.92065731\n    0.        ]]\n-----------------------------------------------------------------------\n100.0\n"}},"pos":2.75,"state":"done","type":"cell"}
{"exec_count":26,"id":"620daa","input":"import numpy as np #Yes I know I don't need this in every block, but I don't want to re-run everything every time Cocalc crashes\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\n# Define constants\nC=900  # J/(kg K)\nRh=2700 # kg/m3\nk=220  # W/(m K\n\n#Turning the last block into a function. Most of the comments and w/e will be the exact same as above, so they're up there if needed.\n#Note: Use a local editor in future\n\ndef LeapfrogLast(dX, dt, tMax, T0, L):\n    \"\"\"Will print the final line of a matrix for T, produced by the leapfog method. Arguments: dX, dt, tMax, T0, L\"\"\"\n    Xwidth = round(L/dX)\n    twidth = round(tMax/dt)\n    Eta = (k * dt) / (C * Rh * (dX**2))\n    TMat = np.ones((twidth + 1, Xwidth + 1))\n    TMat[0] = TMat[0] * T0\n    \n    for y in range (0, twidth + 1): #For all lines, first and last digit are 0\n        TMat[y, 0] = 0\n        TMat[y, Xwidth] = 0\n    \n    TMat = TMat\n    \n    for j in range (0, twidth):\n        for i in range (1, Xwidth):\n            TMat[j + 1,i] = TMat[j,i] + Eta * (TMat[j,i + 1] + TMat[j,i - 1] - 2 * TMat[j,i])\n\n    return(TMat[tMax]) #This will make it return the final line. This should make it easier to plot (or maybe it won't, I don't know)\n\n\ndef LeapfrogFull(dX, dt, tMax, T0, L):\n    \"\"\"Will print the full matrix for T, produced by the leapfog method. Arguments: dX, dt, tMax, T0, L\"\"\"\n    Xwidth = round(L/dX)\n    twidth = round(tMax/dt)\n    Eta = (k * dt) / (C * Rh * (dX**2))\n    TMat = np.ones((twidth + 1, Xwidth + 1))\n    TMat[0] = TMat[0] * T0\n\n    for y in range (0, twidth + 1): #For all lines, first and last digit are 0\n        TMat[y, 0] = 0\n        TMat[y, Xwidth] = 0\n\n    for j in range (0, twidth):\n        for i in range (1, Xwidth):\n            TMat[j + 1,i] = TMat[j,i] + Eta * (TMat[j,i + 1] + TMat[j,i - 1] - 2 * TMat[j,i])\n    return(TMat) #This will return the full matrix. This might make doing a 3D plot easier(Again, I dunno if this is true either)\n\n\ndef TFind(x, t, dX, dt, tMax, T0, L):\n    \"\"\"Finds the value of T, produced by the leapfrog method, for a given x & t. Arguments: x, t, dX, dt, tMax, T0, L. T0 is not used but allows for easy copy-paste of values\"\"\"\n    TMat = LeapfrogFull(dX, dt, tMax, T0, L)\n    TVal = TMat[t, x]\n    return(TVal)\n\ndef ThrDPlot(dX, dt, tMax, T0, L): #I just want to see if this works when put straight into the wireframe plotting function. I didn't do the python course last year, so have no idea what any of this does\n    \"\"\"Will output the X,T required for a 3D plot for T vs x & t. Arguments: dX, dt, tMax, T0, L\"\"\"\n    xs3d = np.linspace(0, L, round(L/dX))\n    ts3d = np.linspace(0, tMax, round(tMax/dt))\n    X, T = np.meshgrid(xs3d, ts3d)\n    return(X, T)\n\n\"\"\"\ndef ThrDPlotMesh(dX, dt, tMax, T0, L):\n    xs3d, ts3d = ThrDPlotLin(dX, dt, tMax, T0, L)\n    X, T = np.meshgrid(xs3d, ts3d)\n    return(X, T)\n\"\"\"\n\nplt.plot(LeapfrogLast(0.01, 0.5, 0, 100, 0.3)) #For t = 0\nplt.xlabel('X Position *10-2')\nplt.ylabel('T')\nplt.show()\n\nplt.plot(LeapfrogLast(0.01, 0.5, 20, 100, 0.3)) #For t = 20\nplt.xlabel('X Position *10-2')\nplt.ylabel('T')\nplt.show()\n\nplt.plot(LeapfrogLast(0.01, 0.5, 100, 100, 0.3)) #For t = 100\nplt.xlabel('X Position *10-2')\nplt.ylabel('T')\nplt.show()\n\"\"\"\nWhilst the plots for t=20, 100 appear to be the same as last week's method, the plot for t=0 is missing the large fluctuations at either end. The peak value for t=100 is also lower that last week's plot\n\"\"\"\nfig = plt.figure()\nax = fig.gca(projection = '3d')\nX, T = ThrDPlot(0.01, 0.5, 100, 100, 0.3)\nax.plot_wireframe(X, T, TFind(X, T, 0.01, 0.5, 100, 100, 0.3) ) #This doesn't work, can't just input the X,T from the 'ThrDPlot' function. Need to find a way to find a way to turn the X & T into values that can be used to index (integers). Presumably we find out the index of the X & T values then put them into here, but I can't think how to do that.\n","kernel":"anaconda5","output":{"0":{"data":{"image/png":"4b5f83f645b2e5b5a81ead9c456ee323abe69fa7"},"metadata":{"image/png":{"height":263,"width":390},"needs_background":"light"}},"1":{"data":{"image/png":"b6ceb387023646eaed66894aa99c7de76b7a30d8"},"metadata":{"image/png":{"height":263,"width":390},"needs_background":"light"}},"2":{"data":{"image/png":"659cf461b324afac22c6cce1e04568a77fbbf018"},"metadata":{"image/png":{"height":263,"width":384},"needs_background":"light"}},"3":{"ename":"IndexError","evalue":"arrays used as indices must be of integer (or boolean) type","traceback":["\u001b[0;31m---------------------------------------------------------------------------\u001b[0m","\u001b[0;31mIndexError\u001b[0m                                Traceback (most recent call last)","\u001b[0;32m<ipython-input-26-5412a5504607>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m()\u001b[0m\n\u001b[1;32m     88\u001b[0m \u001b[0mx\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mt\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mThrDPlotLin\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;36m0.01\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m0.5\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m100\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m100\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m0.3\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     89\u001b[0m \u001b[0mX\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mT\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mThrDPlotMesh\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;36m0.01\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m0.5\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m100\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m100\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m0.3\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 90\u001b[0;31m \u001b[0max\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mplot_wireframe\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mX\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mT\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mTFind\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mx\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mt\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m0.01\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m0.5\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m100\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m100\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m0.3\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m)\u001b[0m \u001b[0;31m#This doesn't work, can't just input the X,T from the 'ThrDPlot function. Need to find a way to find a way to turn the X & T into values that can be used to index\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m","\u001b[0;32m<ipython-input-26-5412a5504607>\u001b[0m in \u001b[0;36mTFind\u001b[0;34m(x, t, dX, dt, tMax, T0, L)\u001b[0m\n\u001b[1;32m     53\u001b[0m     \u001b[0;34m\"\"\"Finds the value of T, produced by the leapfrog method, for a given x & t\"\"\"\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     54\u001b[0m     \u001b[0mTMat\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mLeapfrogFull\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mdX\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdt\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtMax\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mT0\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mL\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 55\u001b[0;31m     \u001b[0mTVal\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mTMat\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mt\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mx\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     56\u001b[0m     \u001b[0;32mreturn\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mTVal\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     57\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;31mIndexError\u001b[0m: arrays used as indices must be of integer (or boolean) type"]},"4":{"data":{"image/png":"ee5b4019a64db321ea45d06594825286a5ed9083"},"metadata":{"image/png":{"height":235,"width":352},"needs_background":"light"}}},"pos":2.5,"state":"done","type":"cell"}
{"id":0,"time":1552505607841,"type":"user"}
{"last_load":1549983279800,"type":"file"}