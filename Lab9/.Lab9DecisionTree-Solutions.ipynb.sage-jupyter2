{"backend_state":"ready","kernel":"anaconda5","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":77381632},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.6.6"}},"trust":true,"type":"settings"}
{"cell_type":"code","end":1554474703158,"exec_count":28,"id":"575155","input":"# Last week's stuff\n#Imports\nimport pandas as pd\nimport numpy as np\nfrom pandas import DataFrame\nfrom matplotlib import pyplot as plt\n\ndef GeneralListPlot(XList, YList, xlabel='X', ylabel='Y'):\n    \"\"\"A general function to plot 2 lists of floats, and label their axes\"\"\"\n    plt.plot(XList, YList)\n    plt.xlabel(xlabel)\n    plt.ylabel(ylabel)\n    plt.show()\n    return()\n\ndef GeneralListScatter(XList, YList, xlabel='X', ylabel='Y'):\n    \"\"\"A general function to plot 2 lists of floats, and label their axes\"\"\"\n    plt.scatter(XList, YList)\n    plt.xlabel(xlabel)\n    plt.ylabel(ylabel)\n    plt.show()\n    return()\n\nsignal = pd.read_csv('../data/signal_training.dat', sep = \" \")\nbackground = pd.read_csv('../data/background_training.dat', sep = \" \")\n\nsigframe = DataFrame(signal)\nbacframe = DataFrame(background)\nfulldatanames = list(signal.keys())\ndatanames = list(signal.keys())[3:]\n","kernel":"anaconda5","pos":1,"scrolled":false,"start":1554474702965,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"8203b8","input":"# Lab 9: A decision tree applied to the neutrino data set\nIn the previous lab session you learned how to use a dataframe to analyse the neutrino data set. Single variable selections were applied on the training data and variables were sorted in order of descending value of the rejection\\* efficiency metric. The goal of this week is to combine selections on multiple variables to achieve the best value possible in our metric.\n\nAs we learned in the Lab session 5, it is important to apply our selection to the \"test\" data set in order to check that we are not training our selections on a statistical fluctuation. For **each** question  of today's lab you should compare the value you achieve for the rejection\\* efficiency on the test data set **without** preparing a new selection.\n\n   * Expand the table you produced last week and add a column for the rejection\\* efficiency using the test data set\n   * Combine the selections identified last week together in groups of 2 to 6 and evaulate the maximum rejection\\* efficiency that can be achieved and compare the training and the test data set results. You should try different combinations without changing the selections optimised last week. How does your best combination compare with the best result achieved last week?\n   * Study correlation between the variables that you identified as \"good\". Prepare scatter plots for pairs of this variables and indicate if these variables are correlated \n   * For the two variables with the best discrimination identified last week, plot the value of rejection\\* efficiency as a function of the selection on the two variables as a colour plot with the two variables as coordinates and the colour indicating the maximum value achieved\n   * Implement a decision tree. Start with the selection with the best discrimination and define the subset of events that satisfy that selection. Then identify the selection giving the best discrimination on the subset and proceed iteratively. Plot or print the best value you achieve as a function of the number of iterations\n   ","pos":0,"state":"done","type":"cell"}
{"collapsed":true,"end":1554469789079,"exec_count":5,"id":"df10bd","input":"# Expand the table you produced last week and add a column for the rejection* efficiency using the test data set\ndef testdata(frame1, frame2, cutvallist, datanames):\n    testexpvallist = []\n    for i in datanames:\n        cutval = cutvallist[datanames.index(i)]\n        nA = len(frame1[i])\n        nAkeepR = len(frame1[frame1[i]>cutval][i])\n        nBkeepR = len(frame2[frame2[i]>cutval][i])\n        nAkeepL = len(frame1[frame1[i]<cutval][i])\n        nBkeepL = len(frame2[frame2[i]<cutval][i])\n        expvalR_ = expval(nA, nAkeepR, nBkeepR)\n        expvalL_ = expval(nA, nAkeepL, nBkeepL)\n        if expvalR_ >= expvalL_:\n            testexpvallist.append(expvalR_)\n        else:\n            testexpvallist.append(expvalL_)\n    return(testexpvallist)\n\nsignaltest = pd.read_csv('../data/signal_data.dat', sep = \" \")\nbackgroundtest = pd.read_csv('../data/background_data.dat', sep = \" \")\n\nsigframetest = DataFrame(signaltest)\nbacframetest = DataFrame(backgroundtest)\n\n# print(len(cutlistF))\n# print(len(fulldatanames))\ntestexplist = testdata(sigframetest, bacframetest, cutlistF, fulldatanames)\nnewtestlist = testexplist[3:]\n\n# Dictionary things:\nP, I, G = 'Poor', 'Intermediate', 'Good'\ndiscr = [I, P, P, I, P, P, P, P, P, P, I, G, G, P, I, P, G, G, I]\ntabledata = {'Variable': datanames, 'Max (Eps X Rho)': newmaxlistF, 'Best cut': newcutlistF, 'Cut Direction': newdirlistF, 'Discriminator': discr, 'Test Data EXR': newtestlist}\ntableframe = DataFrame(tabledata)\n\ndisplay(tableframe)\n# The values this produces are wrong, I can't work out why. It appears that values that should be 0.5 come out as a little bit below.","kernel":"anaconda5","output":{"0":{"data":{"text/html":"<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Variable</th>\n      <th>Max (Eps X Rho)</th>\n      <th>Best cut</th>\n      <th>Cut Direction</th>\n      <th>Discriminator</th>\n      <th>Test Data EXR</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>muonmom</td>\n      <td>0.499925</td>\n      <td>10183</td>\n      <td>&lt;</td>\n      <td>Intermediate</td>\n      <td>0.494949</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>muoncos</td>\n      <td>0.481033</td>\n      <td>-1</td>\n      <td>&gt;</td>\n      <td>Poor</td>\n      <td>0.479480</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>muonpull</td>\n      <td>0.497251</td>\n      <td>3</td>\n      <td>&lt;</td>\n      <td>Poor</td>\n      <td>0.492195</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>ntracks</td>\n      <td>0.578387</td>\n      <td>0</td>\n      <td>&gt;</td>\n      <td>Intermediate</td>\n      <td>0.555651</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>negpionmom</td>\n      <td>0.499950</td>\n      <td>3193</td>\n      <td>&lt;</td>\n      <td>Poor</td>\n      <td>0.494949</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>pospions</td>\n      <td>0.500000</td>\n      <td>-1</td>\n      <td>&gt;</td>\n      <td>Poor</td>\n      <td>0.494949</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>pospionmom</td>\n      <td>0.499850</td>\n      <td>100050</td>\n      <td>&lt;</td>\n      <td>Poor</td>\n      <td>0.494949</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>pospiontheta</td>\n      <td>0.499925</td>\n      <td>2</td>\n      <td>&lt;</td>\n      <td>Poor</td>\n      <td>0.494974</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>pospionz</td>\n      <td>0.499925</td>\n      <td>749</td>\n      <td>&lt;</td>\n      <td>Poor</td>\n      <td>0.494949</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>pi0elpull</td>\n      <td>0.461964</td>\n      <td>1</td>\n      <td>&lt;</td>\n      <td>Poor</td>\n      <td>0.462388</td>\n    </tr>\n    <tr>\n      <th>10</th>\n      <td>piontotale</td>\n      <td>0.608936</td>\n      <td>106</td>\n      <td>&gt;</td>\n      <td>Intermediate</td>\n      <td>0.559584</td>\n    </tr>\n    <tr>\n      <th>11</th>\n      <td>energybalance</td>\n      <td>0.598826</td>\n      <td>-82</td>\n      <td>&gt;</td>\n      <td>Good</td>\n      <td>0.595507</td>\n    </tr>\n    <tr>\n      <th>12</th>\n      <td>nue</td>\n      <td>0.636318</td>\n      <td>2046</td>\n      <td>&gt;</td>\n      <td>Good</td>\n      <td>0.644205</td>\n    </tr>\n    <tr>\n      <th>13</th>\n      <td>muonpos</td>\n      <td>0.499925</td>\n      <td>2943</td>\n      <td>&lt;</td>\n      <td>Poor</td>\n      <td>0.494949</td>\n    </tr>\n    <tr>\n      <th>14</th>\n      <td>muonz</td>\n      <td>0.500000</td>\n      <td>-210</td>\n      <td>&gt;</td>\n      <td>Intermediate</td>\n      <td>0.494949</td>\n    </tr>\n    <tr>\n      <th>15</th>\n      <td>fgdcos</td>\n      <td>0.484670</td>\n      <td>1</td>\n      <td>&lt;</td>\n      <td>Poor</td>\n      <td>0.476431</td>\n    </tr>\n    <tr>\n      <th>16</th>\n      <td>effpullx</td>\n      <td>0.674331</td>\n      <td>0</td>\n      <td>&gt;</td>\n      <td>Good</td>\n      <td>0.653733</td>\n    </tr>\n    <tr>\n      <th>17</th>\n      <td>effpully</td>\n      <td>0.758199</td>\n      <td>0</td>\n      <td>&gt;</td>\n      <td>Good</td>\n      <td>0.741482</td>\n    </tr>\n    <tr>\n      <th>18</th>\n      <td>efftime</td>\n      <td>0.544158</td>\n      <td>1</td>\n      <td>&lt;</td>\n      <td>Intermediate</td>\n      <td>0.546136</td>\n    </tr>\n  </tbody>\n</table>\n</div>"}}},"pos":2,"scrolled":false,"start":1554469788826,"state":"done","type":"cell"}
{"collapsed":true,"exec_count":21,"id":"47a1e8","input":"# # Just a some histograms to show where the cut lines are\n\n# for i in datanames:\n# #     sigframe[sigframe[i]>-999.].loc[:,i].hist(alpha = 0.5, label = 'Signal')\n# #     bacframe[bacframe[i]>-999.].loc[:,i].hist(alpha = 0.5, label = 'Background')\n#     sigframetest[sigframetest[i]>-999.].loc[:,i].hist(alpha = 0.5, label = 'SignalT')\n#     bacframetest[bacframetest[i]>-999.].loc[:,i].hist(alpha = 0.5, label = 'BackgroundT')\n#     plt.axvline(newcutlistF[datanames.index(i)])\n#     plt.title(i)\n#     plt.xlabel((i, 'value')) # This is close enough for now\n#     plt.ylabel('Occurences')\n#     plt.legend()\n#     plt.show()","kernel":"anaconda5","output":{"0":{"data":{"image/png":"d112bcf58317f0f31f8029a6b1f7b0cc050108a3"},"metadata":{"image/png":{"height":277,"width":397},"needs_background":"light"}},"1":{"data":{"image/png":"6fcac19de8857b72f481754be5ea5117b4364d85"},"metadata":{"image/png":{"height":277,"width":402},"needs_background":"light"}},"10":{"data":{"image/png":"148291d7c4346599e92fc29e611fb2451645ffe3"},"metadata":{"image/png":{"height":277,"width":397},"needs_background":"light"}},"11":{"data":{"image/png":"7158a7daac7780c5f43e7581d8cd49f18a5af9ac"},"metadata":{"image/png":{"height":277,"width":397},"needs_background":"light"}},"12":{"data":{"image/png":"3083de65c2f1c67a6e99b7d610f5c3c9531ca0c8"},"metadata":{"image/png":{"height":277,"width":397},"needs_background":"light"}},"13":{"more_output":true},"2":{"data":{"image/png":"de44665525f18c3160105d04e58391a5ca9b55a1"},"metadata":{"image/png":{"height":277,"width":399},"needs_background":"light"}},"3":{"data":{"image/png":"0aa93acb514e416e59ebc6da4a504aa9eec5af4f"},"metadata":{"image/png":{"height":277,"width":397},"needs_background":"light"}},"4":{"data":{"image/png":"57760e32b64547e95db7641b058fd13a8fc57a1a"},"metadata":{"image/png":{"height":277,"width":390},"needs_background":"light"}},"5":{"data":{"image/png":"4123caeba2448992fac1884cf067cbd52d2889d2"},"metadata":{"image/png":{"height":277,"width":397},"needs_background":"light"}},"6":{"data":{"image/png":"960cf0f310ec021c3e835c5f3188177d0ea8af9f"},"metadata":{"image/png":{"height":277,"width":399},"needs_background":"light"}},"7":{"data":{"image/png":"510bc03c3b888b0742c052e8680e60810bd69478"},"metadata":{"image/png":{"height":277,"width":397},"needs_background":"light"}},"8":{"data":{"image/png":"238bdf196fb4a8b4a2dabd7569fcecf38619d06b"},"metadata":{"image/png":{"height":277,"width":390},"needs_background":"light"}},"9":{"data":{"image/png":"3fbe7f9bd0333c5f51c127bfe1d3b599739be26e"},"metadata":{"image/png":{"height":277,"width":394},"needs_background":"light"}}},"pos":3,"scrolled":false,"state":"done","type":"cell"}
{"collapsed":true,"exec_count":34,"id":"5c37fc","input":"# Combine the selections identified last week together in groups of 2 to 6 and evaulate the maximum rejection* efficiency that can be achieved and compare the training and the test data set results.\n# You should try different combinations without changing the selections optimised last week. How does your best combination compare with the best result achieved last week?\n\n# Genuinely having trouble working out what this exercise even wants\n\n# Multiple cuts, e.g. for data where both piontale > cut & nue > cut\n# Useful data (optimum cut doesn't select all data): piontotale, energybalance, nue, effpullx, effpully, efftime\n\n# def pullcut(datanm, cutlist=newcutlistF, datanamelist = datanames):\n#     \"\"\"Returns the value of the optimum cut for a given variable\"\"\"\n#     cutval = cutlist[datanamelist.index(datanm)]\n#     return(cutval)\n\n# It appears we can't just run the frame through 2 logic statements, that just throws errors, so we'll try this:\ndef multicut(datanms, testdata, datalist = datanames, cutlist = newcutlistF, dirlist = newdirlistF):\n    \"\"\"Carries out muliple cuts on data. Requires the data names given in a list\"\"\"\n    testdatarr = []\n    ERlist = []\n    for datanm in datanms:\n        cut, dir_ = cutfind(datanm)\n        ER = ERfind(datanm)\n        datacolumn = testdata.loc[:, datanm]\n        if dir_ == '>':\n            columntemp = datacolumn[datacolumn>cut]\n        elif dir_ == '<':\n            columntemp = datacolumn[datacolumn<cut]\n        testdatarr.append(columntemp)\n        ERlist.append(ER)\n    return(testdatarr, ERlist)\n\n# def multicut2(datanm, testdata, datalist = datanames, cutlist = newcutlistF, dirlist = newdirlistF):\n#     cut, dir_ = cutfind(datanm)\n#     ER = ERfind(datanm)\n#     datacolumn = testdata.loc[:, datanm]\n#     if dir_ == '>':\n#         columntemp = datacolumn[datacolumn>cut]\n#     elif dir_ == '<':\n#         columntemp = datacolumn[datacolumn<cut]\n#     return(columntemp)\n\ndef cutfind(datanm, datalist = datanames ,cutlist = newcutlistF, dirlist = newdirlistF):\n    \"\"\"Gives the value of the optimal cut for a given dataname\"\"\"\n    ind_ = datalist.index(datanm)\n    cutval = cutlist[ind_]\n    dir_ = dirlist[ind_]\n    return(cutval, dir_)\n\ndef ERfind(datanm, ERlist = newmaxlistF, datalist = datanames):\n    \"\"\"Gives the value of the (E*R) metric for a given dataname\"\"\"\n    ind_ = datalist.index(datanm)\n    ER = newmaxlistF[ind_]\n    return(ER)\n    \n# I've been told not to do every combination, and only do a couple\ndatanms1 = ['piontotale', 'energybalance']\ndatanms2 = ['nue', 'effpullx']\ndatanms3= ['piontotale', 'energybalance', 'nue', 'effpullx', 'effpully', 'efftime']\n\nset1, ER1 = multicut(datanms1, sigframetest)\nset2, ER2 = multicut(datanms2, sigframetest)\nset3, ER3  = multicut(datanms3, sigframetest)\n\nGeneralListScatter(set1, ER1) # ValueError: setting an array element with a sequence. --Output the lists separately?\nGeneralListScatter(set2, ER2)\nGeneralListScatter(set3, ER3)\n\n# I have no idea how to make this work. Dataframes man...","kernel":"anaconda5","output":{"0":{"ename":"ValueError","evalue":"setting an array element with a sequence.","traceback":["\u001b[0;31m---------------------------------------------------------------------------\u001b[0m","\u001b[0;31mValueError\u001b[0m                                Traceback (most recent call last)","\u001b[0;32m<ipython-input-34-3410ce64eecf>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m()\u001b[0m\n\u001b[1;32m     58\u001b[0m \u001b[0mset3\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mER3\u001b[0m  \u001b[0;34m=\u001b[0m \u001b[0mmulticut\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mdatanms3\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0msigframetest\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     59\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 60\u001b[0;31m \u001b[0mGeneralListScatter\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mset1\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mER1\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;31m# ValueError: setting an array element with a sequence. --Output the lists separately?\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     61\u001b[0m \u001b[0mGeneralListScatter\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mset2\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mER2\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     62\u001b[0m \u001b[0mGeneralListScatter\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mset3\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mER3\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m<ipython-input-28-58fad6c872b1>\u001b[0m in \u001b[0;36mGeneralListScatter\u001b[0;34m(XList, YList, xlabel, ylabel)\u001b[0m\n\u001b[1;32m     16\u001b[0m \u001b[0;32mdef\u001b[0m \u001b[0mGeneralListScatter\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mXList\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mYList\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mxlabel\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m'X'\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mylabel\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m'Y'\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     17\u001b[0m     \u001b[0;34m\"\"\"A general function to plot 2 lists of floats, and label their axes\"\"\"\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 18\u001b[0;31m     \u001b[0mplt\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mscatter\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mXList\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mYList\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     19\u001b[0m     \u001b[0mplt\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mxlabel\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mxlabel\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     20\u001b[0m     \u001b[0mplt\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mylabel\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mylabel\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/ext/anaconda5/lib/python3.6/site-packages/matplotlib/pyplot.py\u001b[0m in \u001b[0;36mscatter\u001b[0;34m(x, y, s, c, marker, cmap, norm, vmin, vmax, alpha, linewidths, verts, edgecolors, hold, data, **kwargs)\u001b[0m\n\u001b[1;32m   3473\u001b[0m                          \u001b[0mvmin\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mvmin\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mvmax\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mvmax\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0malpha\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0malpha\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   3474\u001b[0m                          \u001b[0mlinewidths\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mlinewidths\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mverts\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mverts\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 3475\u001b[0;31m                          edgecolors=edgecolors, data=data, **kwargs)\n\u001b[0m\u001b[1;32m   3476\u001b[0m     \u001b[0;32mfinally\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   3477\u001b[0m         \u001b[0max\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_hold\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mwashold\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/ext/anaconda5/lib/python3.6/site-packages/matplotlib/__init__.py\u001b[0m in \u001b[0;36minner\u001b[0;34m(ax, *args, **kwargs)\u001b[0m\n\u001b[1;32m   1865\u001b[0m                         \u001b[0;34m\"the Matplotlib list!)\"\u001b[0m \u001b[0;34m%\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0mlabel_namer\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfunc\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m__name__\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1866\u001b[0m                         RuntimeWarning, stacklevel=2)\n\u001b[0;32m-> 1867\u001b[0;31m             \u001b[0;32mreturn\u001b[0m \u001b[0mfunc\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0max\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1868\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1869\u001b[0m         inner.__doc__ = _add_data_doc(inner.__doc__,\n","\u001b[0;32m/ext/anaconda5/lib/python3.6/site-packages/matplotlib/axes/_axes.py\u001b[0m in \u001b[0;36mscatter\u001b[0;34m(self, x, y, s, c, marker, cmap, norm, vmin, vmax, alpha, linewidths, verts, edgecolors, **kwargs)\u001b[0m\n\u001b[1;32m   4332\u001b[0m                 \u001b[0moffsets\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0moffsets\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   4333\u001b[0m                 \u001b[0mtransOffset\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpop\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'transform'\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mtransData\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 4334\u001b[0;31m                 \u001b[0malpha\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0malpha\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   4335\u001b[0m                 )\n\u001b[1;32m   4336\u001b[0m         \u001b[0mcollection\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mset_transform\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mmtransforms\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mIdentityTransform\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/ext/anaconda5/lib/python3.6/site-packages/matplotlib/collections.py\u001b[0m in \u001b[0;36m__init__\u001b[0;34m(self, paths, sizes, **kwargs)\u001b[0m\n\u001b[1;32m    925\u001b[0m         \"\"\"\n\u001b[1;32m    926\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 927\u001b[0;31m         \u001b[0mCollection\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m__init__\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    928\u001b[0m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mset_paths\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mpaths\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    929\u001b[0m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mset_sizes\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0msizes\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/ext/anaconda5/lib/python3.6/site-packages/matplotlib/collections.py\u001b[0m in \u001b[0;36m__init__\u001b[0;34m(self, edgecolors, facecolors, linewidths, linestyles, capstyle, joinstyle, antialiaseds, offsets, transOffset, norm, cmap, pickradius, hatch, urls, offset_position, zorder, **kwargs)\u001b[0m\n\u001b[1;32m    157\u001b[0m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_uniform_offsets\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    158\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0moffsets\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 159\u001b[0;31m             \u001b[0moffsets\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0masanyarray\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0moffsets\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfloat\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    160\u001b[0m             \u001b[0;31m# Broadcast (2,) -> (1, 2) but nothing else.\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    161\u001b[0m             \u001b[0;32mif\u001b[0m \u001b[0moffsets\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mshape\u001b[0m \u001b[0;34m==\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0;36m2\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/ext/anaconda5/lib/python3.6/site-packages/numpy/core/numeric.py\u001b[0m in \u001b[0;36masanyarray\u001b[0;34m(a, dtype, order)\u001b[0m\n\u001b[1;32m    551\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    552\u001b[0m     \"\"\"\n\u001b[0;32m--> 553\u001b[0;31m     \u001b[0;32mreturn\u001b[0m \u001b[0marray\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0ma\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdtype\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcopy\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mFalse\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0morder\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0morder\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0msubok\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mTrue\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    554\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    555\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;31mValueError\u001b[0m: setting an array element with a sequence."]},"1":{"data":{"image/png":"95ba7c939d862c885eeb74eeefe713be9eea6a93"},"metadata":{"image/png":{"height":252,"width":380},"needs_background":"light"}}},"pos":4,"scrolled":true,"state":"done","type":"cell"}
{"end":1554469767028,"id":"cfb1a6","input":"# Study correlation between the variables that you identified as \"good\". Prepare scatter plots for pairs of this variables and indicate if these variables are correlated","kernel":"anaconda5","pos":5,"start":1554469767028,"state":"done","type":"cell"}
{"end":1554469767029,"id":"3f17da","input":"# For the two variables with the best discrimination identified last week, plot the value of rejection* efficiency as a function of the selection on the two variables as a colour plot with the two variables as coordinates and the colour indicating the maximum value achieved","kernel":"anaconda5","pos":6,"start":1554469767029,"state":"done","type":"cell"}
{"exec_count":2,"id":"f2a6d7","input":"# Ignore\n############################################\n## ~ ~ ~ ~ ~ None of this works ~ ~ ~ ~ ~ ##\n############################################\n# (I tried to make it a bit more efficient)\n#\n# def expval(nA, nAkeep, nBkeep):\n#     \"\"\"returns value of Eps X Rho (Efficiency * Purity)\"\"\"\n# #     eff = nAkeep/nA\n# #     try:                                     # Yes, we're doing this again\n# #         pur = nAkeep / (nAkeep + nBkeep)\n# #     except ZeroDivisionError:\n# #         pur = 0\n#     try:\n#         val = (nAkeep ** 2)/(nA*(nAkeep + nBkeep))\n#     except ZeroDivisionError:\n#         val = 0\n#     return(val)\n#\n# def fullExPcalc(frame1, frame2, datanames, dir_, quickrun = 0, debug = 0): # I had to write this twice, cos cocalc, so you'd better like it\n#     \"\"\"Calculates the max (Eps X Rho) values, and their cuts positions, for a pair of data frames, and outputs them as lists\"\"\"\n#     # Todo: Add in a maximise function for the 'B' direction so that all the extra vars & lists aren't needed\n#     expmaxlist = []\n#     cutmaxlist = []\n#     expmaxlistR = []\n#     cutmaxlistR = []\n#     expmaxlistL = []\n#     cutmaxlistL = []\n#     # Attempt to automate the range of the cuts. This seems to slow the program down vs just setting a sensible (but small) range, but allows for more general application\n#     for datacnt in range(len(datanames)): # Produces 2 pandas series (maxima & minima)\n#         cutmaxser = frame1.max(axis = 0)\n#         cutminser = frame1[frame1>-999].min(axis = 0)\n#\n#     for i in datanames:\n#         if debug == 2: # To check datanames are being read correctly\n#             print(i)\n#             print(datanames)\n#         elif debug == 3:\n#             print(i)\n#         expmax = 0\n#         expmaxR = 0\n#         expmaxL = 0\n#\n#         nA = len(frame1[i])\n#\n#         datacnt = datanames.index(i)\n#         cutmax = int(cutmaxser[datacnt]) + 1 # Avoids cutting off the actual max/min due to rounding down/up\n#         cutmin = int(cutminser[datacnt]) - 1\n#\n#         if quickrun == 1: # Time saving option, reduces precision. Could definitely be written better, but I don't feel like working out how to get the order of a value\n#             totrange = (abs(cutmax) + abs(cutmin))\n#             if totrange < 10:\n#                 step = 1\n#             elif totrange < 100:\n#                 step = int(totrange/10)\n#             elif totrange < 1000: # Unneeded, but in case I feel like changing values around\n#                 step = int(totrange/100)\n#             elif totrange < 10000:\n#                 step = int(totrange/100)\n#             else:\n#                 step = int(totrange/500)\n#         else:\n#             step = 1\n#\n#         def expmaxcheck(expval_, cutval, expmax_, debugin = 0):\n#             \"\"\"Checks whether the current value of exp is larger than the current expmax\"\"\"#\n#             expmax = 0\n#             if expval_ > expmax_: # Would making this a var then doing this bit be more efficient? Does it store expval(nA, nAkeep, nBkeep)?\n#                 expmax = expval_\n#                 cutmax = cutval\n#             if debugin == 3:\n#                 print('expmax: ', expmax_, 'V', expval_, 'cutmax: ', cutmax, 'V', cutval)\n#             return(expmax, cutval)\n#\n#         for cutval in range(cutmin, cutmax, step):\n#             if dir_ == 'R':\n#                 nAkeep = len(frame1[frame1[i]>cutval][i])\n#                 nBkeep = len(frame2[frame2[i]>cutval][i])\n#                 expval_ = expval(nA, nAkeep , nBkeep)\n#                 expmax, cutmax = expmaxcheck(expval_, cutval, expmax, debugin = debug)\n#             elif dir_ == 'L':\n#                 nAkeep = len(frame1[frame1[i]<cutval][i])\n#                 nBkeep = len(frame2[frame2[i]<cutval][i])\n#                 expval_ = expval(nA, nAkeep , nBkeep)\n#                 expmax, cutmax = expmaxcheck(expval_, cutval, expmax, debugin = debug)\n#             elif dir_ == 'B':\n#                 nAkeepR = len(frame1[frame1[i]<cutval][i])\n#                 nBkeepR = len(frame2[frame2[i]<cutval][i])\n#                 nAkeepL = len(frame1[frame1[i]>cutval][i])\n#                 nBkeepL = len(frame2[frame2[i]>cutval][i])\n#                 expvalR_ = expval(nA, nAkeepR , nBkeepR)\n#                 expvalL_ = expval(nA, nAkeepL , nBkeepL)\n#                 expmaxR, cutmaxR = expmaxcheck(expvalR_, cutval, expmaxR, debugin = debug)\n#                 expmaxL, cutmaxL = expmaxcheck(expvalL_, cutval, expmaxL, debugin = debug)\n#\n#             if debug == 1: # To check it's outputting correct lengths\n#                 print('Dataname: ', i)\n#                 print('direction: ',dir_)\n#                 print('cutval: ', cutval)\n#                 print('nAkeep: ',nAkeep, 'nBkeep: ', nBkeep, 'nA: ', nA)\n#                 print('Metric: ', expval(nA, nAkeep, nBkeep))\n#         if dir_ == 'B':\n#             cutmaxlistR.append(cutmaxR)\n#             expmaxlistR.append(expmaxR)\n#             cutmaxlistL.append(cutmaxL)\n#             expmaxlistL.append(expmaxL)\n#         else:\n#             cutmaxlist.append(cutmax)\n#             expmaxlist.append(expmax)\n#\n#     if dir_ == 'B':\n#         return(expmaxlistR, cutmaxlistR, expmaxlistL, cutmaxlistL)\n#     else:\n#         return(expmaxlist, cutmaxlist)\n#\n#\n#\n#\n# maxlistR, cutlistR, maxlistL, cutlistL = fullExPcalc(sigframe, bacframe, fulldatanames, 'B', quickrun = 1, debug = 0)\n#\n# # print(len(maxlistR), len(cutlistR), len(maxlistL), len(cutlistL))\n#\n# maxlistF, cutlistF = [],[]\n# for i in range (0,len(maxlistR)):\n#     if maxlistR[i] >= maxlistL[i]:\n#         maxlistF.append(maxlistR[i])\n#         cutlistF.append(cutlistR[i])\n#     elif maxlistL[i] > maxlistR[i]:\n#         maxlistF.append(maxlistL[i])\n#         cutlistF.append(cutlistL[i])\n#\n# newmaxlistF = maxlistF[3:]\n# newcutlistF = cutlistF[3:]","kernel":"anaconda5","pos":1.25,"state":"done","type":"cell"}
{"exec_count":3,"id":"351e9a","input":"############################################\n## TBF This Stuff Probably Doesn't Either ##\n############################################\n\ndef expval(nA, nAkeep, nBkeep):\n    \"\"\"returns value of Eps X Rho (Efficiency * Purity)\"\"\"\n    eff = nAkeep/nA\n    try:                                     # Yes, we're doing this again\n        pur = nAkeep / (nAkeep + nBkeep)\n    except ZeroDivisionError:\n        pur = 0\n    return(eff*pur)\n\ndef fullExPcalc(frame1, frame2, datanames, dir_, quickrun = 0, debug = 0): # I had to write this twice, cos cocalc, so you'd better like it\n    \"\"\"Calculates the max (Eps X Rho) values, and their cuts positions, for a pair of data frames, and outputs them as lists\"\"\"\n    expmaxlist = []\n    cutmaxlist = []\n#     dirlist = []\n    # Attempt to automate the range of the cuts. This seems to slow the program down vs just setting a sensible (but small) range, but allows for more general application\n    for datacnt in range(len(datanames)): # Produces 2 pandas series (maxima & minima)\n        cutmaxser = frame1.max(axis = 0)\n        cutminser = frame1[frame1>-999].min(axis = 0)\n\n    for i in datanames:\n        if debug == 2: # To check datanames are being read correctly\n            print(i)\n            print(datanames)\n        elif debug == 3:\n            print(i)\n        expmax = 0\n        nA = len(frame1[i])\n\n        datacnt = datanames.index(i)\n        cutmax = int(cutmaxser[datacnt]) + 1 # Avoids cutting off the actual max/min due to rounding down/up\n        cutmin = int(cutminser[datacnt]) - 1\n        if quickrun == 1: # Time saving option, reduces precision. Could definitely be written better, but I don't feel like working out how to get the order of a value\n            totrange = (abs(cutmax) + abs(cutmin))\n            if totrange < 10:\n                step = 1\n            elif totrange < 100:\n                step = int(totrange/10)\n            elif totrange < 1000:\n                step = int(totrange/100)\n            elif totrange < 10000:\n                step = int(totrange/100)\n            else:\n                step = int(totrange/500)\n        else:\n            step = 1\n\n        for cutval in range(cutmin, cutmax, step):\n            if dir_ == 'R':\n                nAkeep = len(frame1[frame1[i]>cutval][i])\n                nBkeep = len(frame2[frame2[i]>cutval][i])\n            elif dir_ == 'L':\n                nAkeep = len(frame1[frame1[i]<cutval][i])\n                nBkeep = len(frame2[frame2[i]<cutval][i])\n            else:\n                \"Invalid direction, use 'R' or 'L'\"\n\n            expval_ = expval(nA, nAkeep, nBkeep)\n\n            if expval_ > expmax: # Would making this a var then doing this bit be more efficient? Does it store expval(nA, nAkeep, nBkeep)?\n                expmax = expval_\n                cutmax = cutval\n                if debug == 3:\n                    print('expmax: ', expmax, 'V', expval_, 'cutmax: ', cutmax, 'V', cutval)\n\n            if debug == 1: # To check it's outputting correct lengths\n                print('Dataname: ', i)\n                print('direction: ',dir_)\n                print('cutval: ', cutval)\n                print('nAkeep: ',nAkeep, 'nBkeep: ', nBkeep, 'nA: ', nA)\n                print('Metric: ', expval(nA, nAkeep, nBkeep))\n\n        cutmaxlist.append(cutmax)\n        expmaxlist.append(expmax)\n#         dirlist.append(dir_)\n    return(expmaxlist, cutmaxlist)\n\n# Changing quickrun to 0 will give more precise results, but takes ages to run (I haven't managed to get it to complete yet)\nmaxlistR, cutlistR = fullExPcalc(sigframe, bacframe, fulldatanames, 'R', quickrun = 1, debug = 0)\nmaxlistL, cutlistL = fullExPcalc(sigframe, bacframe, fulldatanames, 'L', quickrun = 1, debug = 0)\n\n# Comparing left and right cut values, taking the best. This could probably do with being a function.\nmaxlistF, cutlistF, dirlistF = [],[],[]\nfor i in range (0,len(maxlistR)):\n    if maxlistR[i] > maxlistL[i]:\n        maxlistF.append(maxlistR[i])\n        cutlistF.append(cutlistR[i])\n        dirlistF.append('>')\n    elif maxlistL[i] > maxlistR[i]:\n        maxlistF.append(maxlistL[i])\n        cutlistF.append(cutlistL[i])\n        dirlistF.append('<')\n\n# Cropping off the first 3 columns (I'm assuming this is wanted)\nnewmaxlistF = maxlistF[3:]\nnewcutlistF = cutlistF[3:]\nnewdirlistF = dirlistF[3:]","kernel":"anaconda5","pos":1.5,"state":"done","type":"cell"}
{"id":"5b5876","input":"# Implement a decision tree. Start with the selection with the best discrimination and define the subset of events that satisfy that selection. Then identify the selection giving the best discrimination on the subset and proceed iteratively. Plot or print the best value you achieve as a function of the number of iterations\n#\n# I don't even know what a decision tree is, nevermind how to implement one","kernel":"anaconda5","pos":7,"state":"done","type":"cell"}
{"id":0,"time":1557159667904,"type":"user"}
{"last_load":1554119942864,"type":"file"}